/**
 * @brief AUTOGENERATED expressions from Mathematica
 */
#include <cmath>
#include <assert.h>
#include <iostream>
#include <stdexcept>

#include "@EXPR_HEADER@"

using namespace std;

#ifdef _WIN32
    #define PRETTY_FUNC_NAME __FUNCDNAME__
#else // __linux
    #define PRETTY_FUNC_NAME __PRETTY_FUNCTION__
#endif

/// @note From eigen_utilities
/// @todo Place in another package
#define common_assert_msg(expr, msg) \
    if (!(expr)) \
    { \
        std::ostringstream os; \
        os << "Assert Error: " << #expr << std::endl << \
            "File: " << __FILE__ ":" << __LINE__ << std::endl << \
            "Function: " << PRETTY_FUNC_NAME << std::endl << \
            "Message: " << msg << std::endl; \
        throw std::runtime_error(os.str()); \
    }

#define common_assert(expr) \
    common_assert_msg(expr, "[None]")

/**
 * \brief Modified Mathematica Definitions file
 * \author Wolfram Research Inc., Copyright 1986 through 1999
 * \author Eric Cousineau - Modified because macros suck.
 */
inline double Power(double x, int y)
{
    // Use overloading to syntactically sneak in some simple optimizations
    if (y < 0)
        return 1. / Power(x, -y);
    double out = 1.;
    for (int i = 0; i < y; ++i)
        out *= x;
    return out;
}
inline double Power(double x, double y) { return pow(x, y); }
inline double Sqrt(double x) { return sqrt(x); }

inline double Abs(double x) { return fabs(x); }

inline double Exp(double x) { return exp(x); }
inline double Log(double x) { return log(x); }

inline double Sin(double x) { return sin(x); }
inline double Cos(double x) { return cos(x); }
inline double Tan(double x) { return tan(x); }

inline double Csc(double x) { return 1. / sin(x); }
inline double Sec(double x) { return 1. / cos(x); }
inline double Cot(double x) { return 1. / tan(x); }

inline double ArcSin(double x) { return asin(x); }
inline double ArcCos(double x) { return acos(x); }
inline double ArcTan(double x) { return atan(x); }

inline double Sinh(double x) { return sinh(x); }
inline double Cosh(double x) { return cosh(x); }
inline double Tanh(double x) { return tanh(x); }

const double E	= 2.71828182845904523536029;
const double Pi = 3.14159265358979323846264;
const double Degree = 0.01745329251994329576924;
    /** @} */

namespace @EXPR_NAMESPACE@ {

/// @todo Use eigen_utilities::assert_size afterwards
    template<typename Derived>
inline void assert_size(const Eigen::MatrixBase<Derived> &X, int rows_expected, int cols_expected)
{
    common_assert_msg(
            X.rows() == rows_expected && X.cols() == cols_expected,
            "matrix [row, col] mismatch" << std::endl << 
                "actual: [" << X.rows() << ", " << X.cols() << "]" << std::endl << 
                "expected: [" << rows_expected << ", " << cols_expected << "]"
    );
}

    template<typename Derived>
inline void assert_size(const Eigen::MatrixBase<Derived> &X, int size_expected)
{
    common_assert_msg(
        X.size() == size_expected,
        "matrix size mismatch" << std::endl << 
            "actual: " << X.size() << std::endl << 
            "expected: " << size_expected
    );
}

@EXPR_DEFINITIONS@

} // namespace @EXPR_NAMESPACE@
