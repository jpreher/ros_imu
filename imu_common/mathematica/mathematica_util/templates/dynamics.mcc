#include "math2mat.hpp"

void docalc(double *matrix, double *x, double *p)
{
  // + <* AmberCpp`Private`nRows *> * sizeof(double)
  Map<VectorXd> dq(x + <* AmberCpp`Private`nRows *>,
		   <* AmberCpp`Private`nRows *>);

  Matrix<double, <* AmberCpp`Private`nRows *>, <* AmberCpp`Private`nCols *> > M, C, foo;

  foo << <* AmberCpp`Private`MCform *>;
  M = foo.transpose();  

  foo << <* AmberCpp`Private`CCform *>;
  C = foo.transpose();
  
  VectorXd G(<* AmberCpp`Private`nRows *>);
  G << <* AmberCpp`Private`GCform *>;
  
  VectorXd f(<* 2*AmberCpp`Private`nRows *>);
  f.head(<* AmberCpp`Private`nRows *>) = dq;
  f.tail(<* AmberCpp`Private`nRows *>) = -(M.inverse()*(C*dq + G));
  //f = C.topRows(1).transpose();

  std::memcpy(matrix, f.data(), <* 2*AmberCpp`Private`nRows *> * sizeof(double));
}

void mexFunction( int nlhs, mxArray *plhs[],
                  int nrhs, const mxArray *prhs[] )
{
  double *matrix, *x, *p;
  size_t mrows, ncols;
  
  /* Check for proper number of arguments. */
  if(nrhs!=2) {
    mexErrMsgIdAndTxt( "MATLAB:Dynamics:invalidNumInputs",
		       "Two inputs required (x, p).");
  } else if(nlhs>1) {
    mexErrMsgIdAndTxt( "MATLAB:Dynamics:maxlhs",
		       "Too many output arguments.");
  }
  
  /* The input must be a noncomplex scalar double.*/
  int i = 0;
  mrows = mxGetM(prhs[i]);
  ncols = mxGetN(prhs[i]);
  if( !mxIsDouble(prhs[i]) || mxIsComplex(prhs[i]) ||
      (!(mrows==<* AmberCpp`Private`nx *> && ncols==1) &&
       !(mrows==1 && ncols==<* 2*AmberCpp`Private`ne + 1*>)) ) {
    mexErrMsgIdAndTxt( "MATLAB:MShaped:inputNotRealVector",
		       "x is wrong.");
  }

  mrows = mxGetM(prhs[++i]);
  ncols = mxGetN(prhs[i]);
  if( !mxIsDouble(prhs[i]) || mxIsComplex(prhs[i]) ||
      (!(mrows==<* AmberCpp`Private`np *> && ncols==1) &&
       !(mrows==1 && ncols==<* AmberCpp`Private`np *>) ) ) {
    mexErrMsgIdAndTxt( "MATLAB:MShaped:inputNotRealVector",
		       "p is wrong.");
  }
  
  /* Create matrix for the return argument. */
  plhs[0] = mxCreateDoubleMatrix((mwSize) <* 2*AmberCpp`Private`nRows *>, 1, mxREAL);
  matrix = mxGetPr(plhs[0]);

  /* Assign pointers to each input and output. */
  x = mxGetPr(prhs[0]);
  p = mxGetPr(prhs[1]);
  
  /* Call the calculation subroutine. */
  docalc(matrix, x, p);
}
